# LeetCode 1557 解题报告

## 思路分析过程

### 首先考虑暴力法

- 题目要求找出最小的节点集合，如果要用暴力法，需要遍历节点数分别为1至n的情况。
- 当节点数为i时，一共有 C(n, i) 种组合。
- 所以总组合数为 sum(C(n, i))，其中 i = 1, 2, ..., n。根据二项式公式，结果为 `2^n - 1`
- 也就是说，暴力法的时间复杂度至少为 O(2^n)，显然不适合。

### 突破：拓扑排序

- 突然想到一个思路：将所有节点拓扑排序，得到若干条链，然后只需考虑每条链的首节点即可。
- 凌晨12点40分入睡，1点23分没睡着，中途突然想到：其实每条链的首节点的集合就是答案了。

### 如何找出每条链

- 先明确这里的「链」的定义：链首没有前驱（即没有节点指向它），链中其他元素均可由链首到达。
- 其实用「树」来描述更合适，原题目转化为：从n个节点找出数量最小的树，能够覆盖所有节点。
- 定义两个map，分别记录每个节点的前驱和后驱，以方便搜索

### 先确定根节点

- 在思考如何将各个节点的 map 合并时（或者说将各棵小树合并时），突然有了新思路：先确定根节点。
- 其实根节点的特征很明显：没人指向它。
- 进一步发现：找到所有没有前驱的节点，就是答案了！原来这么简单！

## 提交结果

- 语言：Python
- 提交时间：2023年5月19日1:53
- 提交次数：1次通过
- 时间开销：1001 ms，击败 28.77%
- 空间开销：54.4 MB，击败 65.75%
- 解题时间：寻找思路累计约30分钟，编码约15分钟。

## 后话

没想到最后只需写两行代码就能解决问题，实在超出我的想象。同时感受到解题的乐趣。
